---
title: "match_boris_watlas"
author: "Niels van der Vegt"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE}
library(lubridate)
library(testit)
library(exifr)
library(stars)
library(sf)
library(ggplot2)
library(tools4watlas)
library(glue)
library(dplyr)
```

```{r}
behaviour_dict <- c(
  "pecking"="active", 
  "probing"="active", 
  "hunting"="active",
  "hunting prey"="active",
  "probing prey"="active",
  "interaction"="active",
  "walking"="active",
  "foraging"="active",
  "unknown prey"="active",
  
  "vigilant"="inactive",
  "preening"="inactive",
  "hopping"="inactive",
  "sleeping"="inactive",
  "scratching"="inactive",
  "standing still"="inactive",
  
  "flying"="flying",
  
  "camera malfunction"="camera malfunction"
)
```

```{r}
preprocess_observation <- function(observation_path) {
  # Metadata preprocessing
  observation <- read.csv(observation_path, sep=';')
  observation_start <- observation[1,2]  # get observation date from metadata
  observation_start <- ymd_hms(observation_start, tz="Europe/Amsterdam")
  observation_lat <- as.numeric(gsub(',', '.', observation[2,2]))
  observation_long <- as.numeric(gsub(',', '.', observation[3,2]))
  observation_tag <- observation[4,2]
  colnames(observation) <- observation[6,]  # get colnames from metadata
  observation_data <- observation[-c(1:6),]  # remove metadata from df
  
  # Body preprocessing
  observation_data$Time <- seconds(observation_data$Time) + observation_start
  observation_data <- observation_data[observation_data$Status != 'START',]
  observation_end <- observation_data[nrow(observation_data), "Time"]
  observation_interval <- interval(observation_start, observation_end)
  
  return(
    list(
      data = observation_data,
      start = observation_start,
      end = observation_end,
      lat = observation_lat,
      long = observation_long,
      tag = observation_tag,
      interval = observation_interval
    )
  )
}
```

```{r}
get_watlas_for_observation <- function(observation) {
  watlas <- read.csv(
    glue('resources/watlas/dunlin-2022-2023/dunlin-{tag}.csv', tag=observation$tag)
  )
  watlas$time <- ymd_hms(watlas$time, tz="UTC")
  watlas$time <- with_tz(watlas$time, tzone = "Europe/Amsterdam")
  watlas_interval <- interval(watlas[1, "time"], watlas[nrow(watlas), "time"])
  
  tryCatch({
    watlas$speed_in <- atl_get_speed(data=watlas, time="TIME", type = "in") 
    watlas$angle <- atl_turning_angle(data=watlas, time="TIME") 
  },
    warning=function(cond) message(paste("Warning during feature calculation:", cond$message))
  )
  
  overlap <- setdiff(observation$interval, watlas_interval)
  watlas <- watlas[watlas$time %within% overlap,]
  
  if (nrow(watlas) == 0) return(NULL)
  
  watlas$behaviour <- sapply(watlas$time, FUN=function(time) {
    x <- time - observation$data$Time
    x <- x[x <= 0]
    closest_observation <- observation$data[which.min(abs(x)), ]
    return(as.character(behaviour_dict[closest_observation$Behavior]))
  })
  
  return(watlas)
}
```

```{r}
files <- list.files('resources/observations', full.names=T)
observations <- list()
validation_data <- data.frame()

for (file in files) {
  print(file)
  observation <- preprocess_observation(file)
  watlas <- get_watlas_for_observation(observation)
  
  if (!is.null(watlas)) {
    validation_data <- bind_rows(validation_data, watlas)
    observations <- append(observations, observation)
  }
}
```

```{r}
validation_data <- validation_data[validation_data$behaviour != 'camera malfunction',]
```

```{r}
write.table(validation_data, 'resources/validation_data.csv', sep=';')
```



